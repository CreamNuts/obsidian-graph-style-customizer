/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphStyleCustomizerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  enabled: true,
  maxHops: 3,
  // Node colors
  selectedNodeColor: "#FF6B6B",
  hopColors: ["#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD"],
  disconnectedOpacity: 0.15,
  // Node shape & size
  defaultNodeShape: "circle" /* CIRCLE */,
  defaultNodeSize: 1,
  activeNodeSize: 1.1,
  // Edge settings
  edgeColorMode: "single" /* SINGLE */,
  edgeColor: "#888888",
  highlightedEdgeColor: "#4ECDC4",
  hopEdgeColors: ["#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD"],
  // Edge width
  activeEdgeWidth: 2,
  defaultEdgeWidth: 1,
  disconnectedEdgeWidth: 0.5,
  // Scope
  applyToGlobalGraph: true,
  applyToLocalGraph: true,
  // Presets
  presets: [],
  activePreset: null,
  // Rules
  rules: []
};
function generateId() {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

// src/settings.ts
var import_obsidian = require("obsidian");
var PatternSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl, getType) {
    super(app, inputEl);
    this.inputElement = inputEl;
    this.ruleType = getType();
    this.getType = getType;
  }
  getSuggestions(query) {
    this.ruleType = this.getType();
    const lowerQuery = query.toLowerCase();
    switch (this.ruleType) {
      case "folder":
        return this.getFolderSuggestions(lowerQuery);
      case "tag":
        return this.getTagSuggestions(lowerQuery);
      case "file":
        return this.getFileSuggestions(lowerQuery);
      default:
        return [];
    }
  }
  getFolderSuggestions(query) {
    const folders = [];
    const allFiles = this.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file instanceof import_obsidian.TFolder && file.path !== "/") {
        const folderPath = file.path + "/";
        if (folderPath.toLowerCase().includes(query) || query === "") {
          folders.push({
            value: folderPath,
            display: folderPath
          });
        }
      }
    }
    return folders.sort((a, b) => {
      const aStarts = a.value.toLowerCase().startsWith(query);
      const bStarts = b.value.toLowerCase().startsWith(query);
      if (aStarts && !bStarts)
        return -1;
      if (!aStarts && bStarts)
        return 1;
      return a.value.localeCompare(b.value);
    }).slice(0, 20);
  }
  getTagSuggestions(query) {
    const tags = [];
    const tagCache = this.app.metadataCache.getTags();
    if (tagCache) {
      for (const tag of Object.keys(tagCache)) {
        if (tag.toLowerCase().includes(query) || query === "") {
          tags.push({
            value: tag,
            display: `${tag} (${tagCache[tag]})`
          });
        }
      }
    }
    return tags.sort((a, b) => {
      const aCount = tagCache[a.value] || 0;
      const bCount = tagCache[b.value] || 0;
      return bCount - aCount;
    }).slice(0, 20);
  }
  getFileSuggestions(query) {
    var _a;
    const files = [];
    const mdFiles = this.app.vault.getMarkdownFiles();
    for (const file of mdFiles) {
      const fileName = file.basename;
      const filePath = file.path;
      if (fileName.toLowerCase().includes(query) || filePath.toLowerCase().includes(query) || query === "") {
        files.push({
          value: filePath,
          display: `${fileName} (${((_a = file.parent) == null ? void 0 : _a.path) || "/"})`
        });
      }
    }
    return files.sort((a, b) => {
      const aStarts = a.value.toLowerCase().includes(query);
      const bStarts = b.value.toLowerCase().includes(query);
      if (aStarts && !bStarts)
        return -1;
      if (!aStarts && bStarts)
        return 1;
      return a.value.localeCompare(b.value);
    }).slice(0, 20);
  }
  renderSuggestion(item, el) {
    el.addClass("graph-style-suggestion-item");
    el.createEl("div", { text: item.display });
  }
  selectSuggestion(item) {
    this.inputElement.value = item.value;
    this.inputElement.dispatchEvent(new Event("input"));
    this.close();
  }
};
function addSliderWithInput(containerEl, name, desc, value, min, max, step, onChange) {
  let sliderComponent;
  let textComponent;
  new import_obsidian.Setting(containerEl).setName(name).setDesc(desc).addSlider((slider) => {
    sliderComponent = slider;
    slider.setLimits(min, max, step).setValue(Math.min(Math.max(value, min), max)).setDynamicTooltip().onChange(async (val) => {
      textComponent.setValue(val.toString());
      await onChange(val);
    });
  }).addText((text) => {
    textComponent = text;
    text.setValue(value.toString()).onChange(async (val) => {
      const num = parseFloat(val);
      if (!isNaN(num) && num >= min && num <= max) {
        sliderComponent.setValue(num);
        await onChange(num);
      }
    });
    text.inputEl.style.width = "60px";
    text.inputEl.type = "number";
    text.inputEl.min = min.toString();
    text.inputEl.max = max.toString();
    text.inputEl.step = step.toString();
  });
}
var RuleEditorModal = class extends import_obsidian.Modal {
  constructor(app, rule, onSave) {
    super(app);
    this.patternSuggest = null;
    this.isNew = !rule;
    this.rule = rule ? { ...rule } : {
      id: generateId(),
      type: "folder",
      pattern: "",
      enabled: true
    };
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.isNew ? "Add Rule" : "Edit Rule" });
    let patternInput;
    new import_obsidian.Setting(contentEl).setName("Rule Type").setDesc("What should this rule match?").addDropdown((dropdown) => {
      dropdown.addOption("folder", "Folder").addOption("tag", "Tag").addOption("file", "File").setValue(this.rule.type || "folder").onChange((value) => {
        this.rule.type = value;
        if (patternInput) {
          patternInput.setPlaceholder(this.getPlaceholder());
        }
      });
    });
    new import_obsidian.Setting(contentEl).setName("Pattern").setDesc("Start typing to see suggestions from your vault").addText((text) => {
      patternInput = text;
      text.setPlaceholder(this.getPlaceholder()).setValue(this.rule.pattern || "").onChange((value) => {
        this.rule.pattern = value;
      });
      text.inputEl.style.width = "300px";
      this.patternSuggest = new PatternSuggest(
        this.app,
        text.inputEl,
        () => this.rule.type || "folder"
      );
    });
    new import_obsidian.Setting(contentEl).setName("Color").setDesc("Node color (optional)").addColorPicker((picker) => {
      picker.setValue(this.rule.color || "#4ECDC4").onChange((value) => {
        this.rule.color = value;
      });
    }).addToggle((toggle) => {
      toggle.setValue(!!this.rule.color).setTooltip("Enable color").onChange((value) => {
        if (!value) {
          delete this.rule.color;
        } else {
          this.rule.color = "#4ECDC4";
        }
      });
    });
    new import_obsidian.Setting(contentEl).setName("Size").setDesc("Node size multiplier (0.8 - 1.5, optional)").addSlider((slider) => {
      slider.setLimits(0.8, 1.5, 0.05).setValue(this.rule.size || 1).setDynamicTooltip().onChange((value) => {
        this.rule.size = value;
      });
    }).addToggle((toggle) => {
      toggle.setValue(this.rule.size !== void 0).setTooltip("Enable size override").onChange((value) => {
        if (!value) {
          delete this.rule.size;
        } else {
          this.rule.size = 1;
        }
      });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Cancel").onClick(() => this.close());
    }).addButton((btn) => {
      btn.setButtonText("Save").setCta().onClick(() => {
        if (!this.rule.pattern) {
          return;
        }
        if (this.rule.type === "tag" && !this.rule.pattern.startsWith("#")) {
          this.rule.pattern = "#" + this.rule.pattern;
        }
        this.onSave(this.rule);
        this.close();
      });
    });
  }
  getPlaceholder() {
    switch (this.rule.type) {
      case "folder":
        return "01_Projects/";
      case "tag":
        return "#project";
      case "file":
        return "note.md";
      default:
        return "";
    }
  }
  onClose() {
    if (this.patternSuggest) {
      this.patternSuggest.close();
    }
    this.contentEl.empty();
  }
};
var GraphStyleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("graph-style-customizer-settings");
    containerEl.createEl("h1", { text: "Graph Style Customizer" });
    new import_obsidian.Setting(containerEl).setName("Enable styling").setDesc("Toggle graph style customization on/off").addToggle((toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
      this.plugin.settings.enabled = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Node Colors" });
    addSliderWithInput(
      containerEl,
      "Maximum hops",
      "How many levels of neighbors to highlight (1-5)",
      this.plugin.settings.maxHops,
      1,
      5,
      1,
      async (value) => {
        this.plugin.settings.maxHops = value;
        await this.plugin.saveSettings();
        this.display();
      }
    );
    new import_obsidian.Setting(containerEl).setName("Active node color").setDesc("Color of the currently selected/active note").addColorPicker((picker) => picker.setValue(this.plugin.settings.selectedNodeColor).onChange(async (value) => {
      this.plugin.settings.selectedNodeColor = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Neighbor Colors by Hop Distance" });
    for (let i = 0; i < this.plugin.settings.maxHops; i++) {
      new import_obsidian.Setting(containerEl).setName(`${i + 1}-hop neighbor`).setDesc(`Color for notes ${i + 1} link${i > 0 ? "s" : ""} away`).addColorPicker((picker) => picker.setValue(this.plugin.settings.hopColors[i] || DEFAULT_SETTINGS.hopColors[i]).onChange(async (value) => {
        this.plugin.settings.hopColors[i] = value;
        await this.plugin.saveSettings();
      }));
    }
    addSliderWithInput(
      containerEl,
      "Disconnected node opacity",
      "Opacity for unconnected nodes (0-100%)",
      this.plugin.settings.disconnectedOpacity * 100,
      0,
      100,
      5,
      async (value) => {
        this.plugin.settings.disconnectedOpacity = value / 100;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h2", { text: "Node Size" });
    addSliderWithInput(
      containerEl,
      "Default node size",
      "Size multiplier for all nodes",
      this.plugin.settings.defaultNodeSize,
      0.1,
      5,
      0.1,
      async (value) => {
        this.plugin.settings.defaultNodeSize = value;
        await this.plugin.saveSettings();
      }
    );
    addSliderWithInput(
      containerEl,
      "Active node size",
      "Size multiplier for the active node",
      this.plugin.settings.activeNodeSize,
      0.1,
      5,
      0.1,
      async (value) => {
        this.plugin.settings.activeNodeSize = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h2", { text: "Edge Colors" });
    new import_obsidian.Setting(containerEl).setName("Edge color mode").setDesc("How edge colors are determined").addDropdown((dropdown) => {
      dropdown.addOption("single" /* SINGLE */, "Single color").addOption("inherit" /* INHERIT */, "Inherit from source node").addOption("by-hop" /* BY_HOP */, "By hop distance").setValue(this.plugin.settings.edgeColorMode).onChange(async (value) => {
        this.plugin.settings.edgeColorMode = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.edgeColorMode === "single" /* SINGLE */) {
      new import_obsidian.Setting(containerEl).setName("Edge color").setDesc("Color for all edges").addColorPicker((picker) => picker.setValue(this.plugin.settings.edgeColor).onChange(async (value) => {
        this.plugin.settings.edgeColor = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Highlighted edge color").setDesc("Color for edges directly connected to the active node").addColorPicker((picker) => picker.setValue(this.plugin.settings.highlightedEdgeColor).onChange(async (value) => {
        this.plugin.settings.highlightedEdgeColor = value;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.edgeColorMode === "by-hop" /* BY_HOP */) {
      containerEl.createEl("h3", { text: "Edge Colors by Hop Distance" });
      for (let i = 0; i < this.plugin.settings.maxHops; i++) {
        new import_obsidian.Setting(containerEl).setName(`${i + 1}-hop edge`).setDesc(`Color for edges at ${i + 1} hop distance`).addColorPicker((picker) => picker.setValue(this.plugin.settings.hopEdgeColors[i] || DEFAULT_SETTINGS.hopEdgeColors[i]).onChange(async (value) => {
          this.plugin.settings.hopEdgeColors[i] = value;
          await this.plugin.saveSettings();
        }));
      }
    }
    containerEl.createEl("h2", { text: "Edge Width" });
    addSliderWithInput(
      containerEl,
      "Active edge width",
      "Width multiplier for edges connected to active node",
      this.plugin.settings.activeEdgeWidth,
      0.1,
      5,
      0.1,
      async (value) => {
        this.plugin.settings.activeEdgeWidth = value;
        await this.plugin.saveSettings();
      }
    );
    addSliderWithInput(
      containerEl,
      "Default edge width",
      "Width multiplier for edges within hop range",
      this.plugin.settings.defaultEdgeWidth,
      0.1,
      5,
      0.1,
      async (value) => {
        this.plugin.settings.defaultEdgeWidth = value;
        await this.plugin.saveSettings();
      }
    );
    addSliderWithInput(
      containerEl,
      "Disconnected edge width",
      "Width multiplier for edges outside hop range",
      this.plugin.settings.disconnectedEdgeWidth,
      0.1,
      5,
      0.1,
      async (value) => {
        this.plugin.settings.disconnectedEdgeWidth = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h2", { text: "Apply To" });
    new import_obsidian.Setting(containerEl).setName("Global graph").setDesc("Apply styling to the global graph view").addToggle((toggle) => toggle.setValue(this.plugin.settings.applyToGlobalGraph).onChange(async (value) => {
      this.plugin.settings.applyToGlobalGraph = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Local graph").setDesc("Apply styling to local graph panels").addToggle((toggle) => toggle.setValue(this.plugin.settings.applyToLocalGraph).onChange(async (value) => {
      this.plugin.settings.applyToLocalGraph = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Style Rules" });
    containerEl.createEl("p", {
      text: "Rules are applied in order. Drag to reorder. First matching rule wins.",
      cls: "setting-item-description"
    });
    const rulesContainer = containerEl.createDiv({ cls: "rules-container" });
    this.renderRulesList(rulesContainer);
    new import_obsidian.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add Rule").setCta().onClick(() => {
        new RuleEditorModal(this.app, null, async (rule) => {
          this.plugin.settings.rules.push(rule);
          await this.plugin.saveSettings();
          this.display();
        }).open();
      });
    });
    containerEl.createEl("h2", { text: "Presets" });
    if (this.plugin.settings.presets.length > 0) {
      this.plugin.settings.presets.forEach((preset, index) => {
        new import_obsidian.Setting(containerEl).setName(preset.name).setDesc(this.plugin.settings.activePreset === preset.name ? "Active" : "").addButton((btn) => btn.setButtonText("Apply").onClick(() => {
          this.plugin.applyPreset(preset.name);
          this.display();
        })).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(async () => {
          this.plugin.settings.presets.splice(index, 1);
          if (this.plugin.settings.activePreset === preset.name) {
            this.plugin.settings.activePreset = null;
          }
          await this.plugin.saveSettings();
          this.display();
        }));
      });
    } else {
      containerEl.createEl("p", {
        text: "No presets saved yet.",
        cls: "setting-item-description"
      });
    }
    let presetNameInput;
    new import_obsidian.Setting(containerEl).setName("Save current settings as preset").addText((text) => {
      presetNameInput = text;
      text.setPlaceholder("Preset name");
    }).addButton((btn) => btn.setButtonText("Save").setCta().onClick(async () => {
      const name = presetNameInput.getValue().trim();
      if (!name)
        return;
      const { presets, activePreset, rules, ...currentSettings } = this.plugin.settings;
      const newPreset = {
        name,
        settings: { ...currentSettings, rules: [...rules] }
      };
      const existingIndex = this.plugin.settings.presets.findIndex((p) => p.name === name);
      if (existingIndex >= 0) {
        this.plugin.settings.presets[existingIndex] = newPreset;
      } else {
        this.plugin.settings.presets.push(newPreset);
      }
      this.plugin.settings.activePreset = name;
      await this.plugin.saveSettings();
      this.display();
    }));
    containerEl.createEl("h2", { text: "Reset" });
    new import_obsidian.Setting(containerEl).setName("Reset to defaults").setDesc("Reset all settings to their default values (presets are preserved)").addButton((btn) => btn.setButtonText("Reset").setWarning().onClick(async () => {
      const { presets, activePreset } = this.plugin.settings;
      this.plugin.settings = { ...DEFAULT_SETTINGS, presets, activePreset };
      await this.plugin.saveSettings();
      this.display();
    }));
  }
  renderRulesList(container) {
    container.empty();
    if (this.plugin.settings.rules.length === 0) {
      container.createEl("p", {
        text: "No rules defined. Add a rule to customize specific nodes.",
        cls: "setting-item-description"
      });
      return;
    }
    this.plugin.settings.rules.forEach((rule, index) => {
      const ruleEl = container.createDiv({ cls: "rule-item" });
      ruleEl.setAttribute("draggable", "true");
      ruleEl.dataset.index = index.toString();
      const dragHandle = ruleEl.createSpan({ cls: "rule-drag-handle", text: "\u22EE\u22EE" });
      const typeBadge = ruleEl.createSpan({ cls: `rule-type-badge rule-type-${rule.type}` });
      typeBadge.textContent = rule.type.charAt(0).toUpperCase();
      const patternEl = ruleEl.createSpan({ cls: "rule-pattern" });
      patternEl.textContent = rule.pattern;
      if (rule.color) {
        const colorPreview = ruleEl.createSpan({ cls: "rule-color-preview" });
        colorPreview.style.backgroundColor = rule.color;
      }
      if (rule.shape) {
        const shapeIcon = ruleEl.createSpan({ cls: "rule-shape-icon" });
        shapeIcon.textContent = this.getShapeIcon(rule.shape);
      }
      if (rule.size !== void 0) {
        const sizeIndicator = ruleEl.createSpan({ cls: "rule-size-indicator" });
        sizeIndicator.textContent = `${rule.size.toFixed(1)}x`;
      }
      const toggleEl = ruleEl.createEl("input", { type: "checkbox", cls: "rule-enabled-toggle" });
      toggleEl.checked = rule.enabled;
      toggleEl.addEventListener("change", async () => {
        this.plugin.settings.rules[index].enabled = toggleEl.checked;
        await this.plugin.saveSettings();
      });
      const editBtn = ruleEl.createEl("button", { cls: "rule-edit-btn", text: "Edit" });
      editBtn.addEventListener("click", () => {
        new RuleEditorModal(this.app, rule, async (updatedRule) => {
          this.plugin.settings.rules[index] = updatedRule;
          await this.plugin.saveSettings();
          this.display();
        }).open();
      });
      const deleteBtn = ruleEl.createEl("button", { cls: "rule-delete-btn", text: "\xD7" });
      deleteBtn.addEventListener("click", async () => {
        this.plugin.settings.rules.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      });
      ruleEl.addEventListener("dragstart", (e) => {
        var _a;
        (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", index.toString());
        ruleEl.addClass("dragging");
      });
      ruleEl.addEventListener("dragend", () => {
        ruleEl.removeClass("dragging");
      });
      ruleEl.addEventListener("dragover", (e) => {
        e.preventDefault();
        ruleEl.addClass("drag-over");
      });
      ruleEl.addEventListener("dragleave", () => {
        ruleEl.removeClass("drag-over");
      });
      ruleEl.addEventListener("drop", async (e) => {
        var _a;
        e.preventDefault();
        ruleEl.removeClass("drag-over");
        const fromIndex = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "0");
        const toIndex = index;
        if (fromIndex !== toIndex) {
          const [movedRule] = this.plugin.settings.rules.splice(fromIndex, 1);
          this.plugin.settings.rules.splice(toIndex, 0, movedRule);
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
  }
  getShapeIcon(shape) {
    switch (shape) {
      case "circle" /* CIRCLE */:
        return "\u25CF";
      case "square" /* SQUARE */:
        return "\u25A0";
      case "diamond" /* DIAMOND */:
        return "\u25C6";
      case "triangle" /* TRIANGLE */:
        return "\u25B2";
      case "hexagon" /* HEXAGON */:
        return "\u2B21";
      default:
        return "?";
    }
  }
};

// src/graphStyler.ts
var import_obsidian2 = require("obsidian");

// src/neighborFinder.ts
var NeighborFinder = class {
  constructor() {
    this.adjacencyList = /* @__PURE__ */ new Map();
  }
  /**
   * Build adjacency list from node connections
   */
  buildFromNodes(nodes) {
    this.adjacencyList.clear();
    const nodeEntries = [];
    if (nodes instanceof Map) {
      nodes.forEach((node, id) => nodeEntries.push([id, node]));
    } else if (Array.isArray(nodes)) {
      nodes.forEach((node) => {
        if (node && node.id) {
          nodeEntries.push([node.id, node]);
        }
      });
    } else if (typeof nodes === "object") {
      Object.entries(nodes).forEach(([id, node]) => {
        nodeEntries.push([id, node]);
      });
    }
    nodeEntries.forEach(([id]) => {
      if (!this.adjacencyList.has(id)) {
        this.adjacencyList.set(id, /* @__PURE__ */ new Set());
      }
    });
    nodeEntries.forEach(([id, node]) => {
      if (!node)
        return;
      const forwardLinks = this.getLinks(node, "forward");
      forwardLinks.forEach((targetId) => {
        this.addEdge(id, targetId);
      });
      const reverseLinks = this.getLinks(node, "reverse");
      reverseLinks.forEach((sourceId) => {
        this.addEdge(sourceId, id);
      });
    });
  }
  getLinks(node, direction) {
    const links = [];
    const linkData = node[direction];
    if (!linkData)
      return links;
    try {
      if (typeof linkData.forEach === "function") {
        linkData.forEach((target, key) => {
          if (typeof key === "string" && key.includes("/")) {
            links.push(key);
          } else if (typeof target === "string") {
            links.push(target);
          } else if (target && target.id) {
            links.push(target.id);
          }
        });
      } else if (typeof linkData === "object") {
        Object.keys(linkData).forEach((key) => {
          links.push(key);
        });
      }
    } catch (e) {
      console.warn("Error parsing links:", e);
    }
    return links;
  }
  addEdge(from, to) {
    if (!this.adjacencyList.has(from)) {
      this.adjacencyList.set(from, /* @__PURE__ */ new Set());
    }
    if (!this.adjacencyList.has(to)) {
      this.adjacencyList.set(to, /* @__PURE__ */ new Set());
    }
    this.adjacencyList.get(from).add(to);
    this.adjacencyList.get(to).add(from);
  }
  /**
   * BFS to find all nodes within n hops, categorized by distance
   */
  findNeighborsByHop(sourceId, maxHops) {
    const result = /* @__PURE__ */ new Map();
    for (let hop = 1; hop <= maxHops; hop++) {
      result.set(hop, /* @__PURE__ */ new Set());
    }
    if (!this.adjacencyList.has(sourceId)) {
      return result;
    }
    const visited = /* @__PURE__ */ new Set();
    const queue = [[sourceId, 0]];
    visited.add(sourceId);
    while (queue.length > 0) {
      const [currentId, distance] = queue.shift();
      if (distance > 0 && distance <= maxHops) {
        result.get(distance).add(currentId);
      }
      if (distance < maxHops) {
        const neighbors = this.adjacencyList.get(currentId) || /* @__PURE__ */ new Set();
        neighbors.forEach((neighborId) => {
          if (!visited.has(neighborId)) {
            visited.add(neighborId);
            queue.push([neighborId, distance + 1]);
          }
        });
      }
    }
    return result;
  }
  /**
   * Get all connected nodes using BFS
   */
  getAllConnectedNodes(sourceId) {
    const connected = /* @__PURE__ */ new Set();
    if (!this.adjacencyList.has(sourceId)) {
      return connected;
    }
    const visited = /* @__PURE__ */ new Set();
    const queue = [sourceId];
    visited.add(sourceId);
    while (queue.length > 0) {
      const currentId = queue.shift();
      if (currentId !== sourceId) {
        connected.add(currentId);
      }
      const neighbors = this.adjacencyList.get(currentId) || /* @__PURE__ */ new Set();
      neighbors.forEach((neighborId) => {
        if (!visited.has(neighborId)) {
          visited.add(neighborId);
          queue.push(neighborId);
        }
      });
    }
    return connected;
  }
  /**
   * Get immediate neighbors (1-hop)
   */
  getDirectNeighbors(sourceId) {
    return this.adjacencyList.get(sourceId) || /* @__PURE__ */ new Set();
  }
  hasNodes() {
    return this.adjacencyList.size > 0;
  }
  getNodeCount() {
    return this.adjacencyList.size;
  }
};

// src/graphStyler.ts
var GraphStyler = class {
  constructor(leaf, settings, app) {
    this.lastActiveNodeId = null;
    this.isInitialized = false;
    // Style tracking
    this.nodeStyles = /* @__PURE__ */ new Map();
    this.edgeStyles = /* @__PURE__ */ new Map();
    // Cache for hop levels
    this.nodeHopLevels = /* @__PURE__ */ new Map();
    // Note: We no longer store original scales for nodes or edges
    // Obsidian dynamically manages scale based on zoom level
    // We only multiply the current scale when our multiplier != 1.0
    // Proxy tracking - store original methods to restore later
    this.proxiedNodes = /* @__PURE__ */ new Set();
    this.proxiedLinks = /* @__PURE__ */ new Set();
    this.originalRenderMethods = /* @__PURE__ */ new Map();
    this.originalLinkRenderMethods = /* @__PURE__ */ new Map();
    // Animation frame for timelapse support
    this.rafId = null;
    this.lastNodeCount = 0;
    this.lastLinkCount = 0;
    this.leaf = leaf;
    this.settings = settings;
    this.app = app;
    this.neighborFinder = new NeighborFinder();
    this.initialize();
  }
  initialize() {
    const renderer = this.getRenderer();
    if (renderer == null ? void 0 : renderer.nodes) {
      this.isInitialized = true;
      this.applyStyles();
      this.startTicker();
    } else {
      setTimeout(() => this.initialize(), 200);
    }
  }
  /**
   * Start animation loop to detect changes during timelapse
   */
  startTicker() {
    if (this.rafId !== null)
      return;
    const loop = () => {
      this.checkForChanges();
      this.rafId = requestAnimationFrame(loop);
    };
    this.rafId = requestAnimationFrame(loop);
  }
  /**
   * Stop the animation loop
   */
  stopTicker() {
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }
  /**
   * Check if nodes or links have been added (e.g., during timelapse)
   * and try to setup render proxies for new nodes
   */
  checkForChanges() {
    var _a, _b;
    if (!this.settings.enabled)
      return;
    const renderer = this.getRenderer();
    if (!(renderer == null ? void 0 : renderer.nodes))
      return;
    const nodeEntries = this.getNodeEntries(renderer.nodes);
    const currentNodeCount = nodeEntries.length;
    const currentLinkCount = ((_a = renderer.links) == null ? void 0 : _a.length) || 0;
    let hasNewProxies = false;
    nodeEntries.forEach(([nodeId, node]) => {
      if (!this.proxiedNodes.has(nodeId) && node && typeof node.render === "function") {
        this.setupRenderProxy(nodeId, node);
        hasNewProxies = true;
      }
    });
    (_b = renderer.links) == null ? void 0 : _b.forEach((link) => {
      if (!this.proxiedLinks.has(link) && link && typeof link.render === "function") {
        this.setupLinkRenderProxy(link);
        hasNewProxies = true;
      }
    });
    if (currentNodeCount !== this.lastNodeCount || currentLinkCount !== this.lastLinkCount || hasNewProxies) {
      this.lastNodeCount = currentNodeCount;
      this.lastLinkCount = currentLinkCount;
      this.applyStyles();
    }
    this.forceApplyNodeStyles(nodeEntries);
  }
  /**
   * Force apply styles directly to node circles
   * This is needed during timelapse when render() is not called
   * Note: Only color/alpha are applied; scale is not supported during timelapse
   */
  forceApplyNodeStyles(nodeEntries) {
    nodeEntries.forEach(([nodeId, node]) => {
      const style = this.nodeStyles.get(nodeId);
      if (style && node.circle) {
        node.circle.tint = style.tint;
        node.circle.alpha = style.alpha;
      }
    });
  }
  getRenderer() {
    try {
      const view = this.leaf.view;
      return (view == null ? void 0 : view.renderer) || (view == null ? void 0 : view.dataEngine) || (view == null ? void 0 : view.engine) || null;
    } catch (e) {
      return null;
    }
  }
  getNodeEntries(nodes) {
    const entries = [];
    if (!nodes)
      return entries;
    try {
      if (nodes instanceof Map) {
        nodes.forEach((node, id) => entries.push([id, node]));
      } else if (Array.isArray(nodes)) {
        nodes.forEach((node) => {
          if (node == null ? void 0 : node.id)
            entries.push([node.id, node]);
        });
      } else if (typeof nodes === "object") {
        Object.entries(nodes).forEach(([id, node]) => {
          entries.push([id, node]);
        });
      }
    } catch (e) {
    }
    return entries;
  }
  getActiveFile() {
    var _a;
    const viewType = this.leaf.view.getViewType();
    if (viewType === "localgraph") {
      const view = this.leaf.view;
      if ((_a = view.file) == null ? void 0 : _a.path) {
        return this.app.vault.getAbstractFileByPath(view.file.path);
      }
    }
    return this.app.workspace.getActiveFile();
  }
  /**
   * Setup render proxy on a node - this is the key technique from extended-graph
   * By proxying the render method, we can apply our styles AFTER each render
   */
  setupRenderProxy(nodeId, node) {
    if (this.proxiedNodes.has(nodeId))
      return;
    if (!node || typeof node.render !== "function")
      return;
    const originalRender = node.render.bind(node);
    this.originalRenderMethods.set(nodeId, originalRender);
    const self = this;
    node.render = function(...args) {
      const result = originalRender(...args);
      if (self.settings.enabled) {
        const style = self.nodeStyles.get(nodeId);
        if (style && node.circle) {
          node.circle.tint = style.tint;
          node.circle.alpha = style.alpha;
          const multiplier = style.size || 1;
          if (multiplier !== 1 && node.circle.scale) {
            node.circle.scale.x *= multiplier;
            node.circle.scale.y *= multiplier;
          }
          if (node.text) {
            node.text.alpha = style.alpha;
          }
        }
      }
      return result;
    };
    this.proxiedNodes.add(nodeId);
  }
  /**
   * Setup render proxy on a link
   * IMPORTANT: We only modify scale.y (thickness), NOT scale.x (length)
   * Both are dynamically managed by Obsidian - we only multiply when width != 1.0
   */
  setupLinkRenderProxy(link) {
    if (this.proxiedLinks.has(link))
      return;
    if (!link || typeof link.render !== "function")
      return;
    const originalRender = link.render.bind(link);
    this.originalLinkRenderMethods.set(link, originalRender);
    const self = this;
    link.render = function(...args) {
      const result = originalRender(...args);
      if (self.settings.enabled) {
        const style = self.edgeStyles.get(link);
        if (style) {
          if (link.line) {
            link.line.tint = style.tint;
            link.line.alpha = style.alpha;
            if (style.width !== 1 && link.line.scale) {
              link.line.scale.y *= style.width;
            }
          }
          if (link.arrow) {
            link.arrow.tint = style.tint;
          }
        }
      }
      return result;
    };
    this.proxiedLinks.add(link);
  }
  /**
   * Calculate and cache styles based on hop distance
   */
  applyStyles() {
    if (!this.settings.enabled) {
      this.clearStyles();
      return;
    }
    const renderer = this.getRenderer();
    if (!(renderer == null ? void 0 : renderer.nodes))
      return;
    const activeFile = this.getActiveFile();
    let activeNodeId = null;
    if (activeFile) {
      activeNodeId = activeFile.path;
      this.lastActiveNodeId = activeNodeId;
    } else if (this.lastActiveNodeId) {
      activeNodeId = this.lastActiveNodeId;
    }
    this.neighborFinder.buildFromNodes(renderer.nodes);
    let neighborsByHop = /* @__PURE__ */ new Map();
    let allConnected = /* @__PURE__ */ new Set();
    if (activeNodeId) {
      neighborsByHop = this.neighborFinder.findNeighborsByHop(
        activeNodeId,
        this.settings.maxHops
      );
      allConnected = this.neighborFinder.getAllConnectedNodes(activeNodeId);
    }
    this.nodeHopLevels.clear();
    const nodeEntries = this.getNodeEntries(renderer.nodes);
    nodeEntries.forEach(([nodeId, node]) => {
      var _a;
      this.setupRenderProxy(nodeId, node);
      let color;
      let alpha;
      let shape;
      let size;
      let hopLevel = -1;
      if (activeNodeId) {
        if (nodeId === activeNodeId) {
          hopLevel = 0;
        } else {
          for (let hop = 1; hop <= this.settings.maxHops; hop++) {
            if ((_a = neighborsByHop.get(hop)) == null ? void 0 : _a.has(nodeId)) {
              hopLevel = hop;
              break;
            }
          }
          if (hopLevel === -1 && allConnected.has(nodeId)) {
            hopLevel = this.settings.maxHops + 1;
          }
        }
      }
      this.nodeHopLevels.set(nodeId, hopLevel);
      const ruleStyle = this.getStyleFromRules(nodeId);
      if (activeNodeId && nodeId === activeNodeId) {
        color = this.settings.selectedNodeColor;
        alpha = 1;
        size = this.settings.activeNodeSize;
      } else if (hopLevel > 0 && hopLevel <= this.settings.maxHops) {
        color = (ruleStyle == null ? void 0 : ruleStyle.color) || this.settings.hopColors[hopLevel - 1] || this.settings.hopColors[0];
        alpha = 1;
      } else if (!activeNodeId) {
        color = (ruleStyle == null ? void 0 : ruleStyle.color) || this.settings.hopColors[0];
        alpha = 1;
      } else if (hopLevel === -1) {
        color = (ruleStyle == null ? void 0 : ruleStyle.color) || "#888888";
        alpha = this.settings.disconnectedOpacity;
      } else {
        color = (ruleStyle == null ? void 0 : ruleStyle.color) || "#888888";
        alpha = 0.5;
      }
      shape = (ruleStyle == null ? void 0 : ruleStyle.shape) || this.settings.defaultNodeShape;
      if (size === void 0) {
        size = (ruleStyle == null ? void 0 : ruleStyle.size) || this.settings.defaultNodeSize;
      }
      this.nodeStyles.set(nodeId, {
        tint: this.parseColor(color),
        alpha,
        shape,
        size
      });
      if (node.circle) {
        node.circle.tint = this.parseColor(color);
        node.circle.alpha = alpha;
        const multiplier = size || 1;
        if (multiplier !== 1 && node.circle.scale) {
          node.circle.scale.x *= multiplier;
          node.circle.scale.y *= multiplier;
        }
        if (node.text) {
          node.text.alpha = alpha;
        }
      }
    });
    this.applyEdgeStyles(renderer, activeNodeId, neighborsByHop);
    if (renderer.changed) {
      renderer.changed();
    }
  }
  applyEdgeStyles(renderer, activeNodeId, neighborsByHop) {
    if (!renderer.links)
      return;
    renderer.links.forEach((link) => {
      var _a, _b, _c, _d, _e, _f;
      this.setupLinkRenderProxy(link);
      const sourceId = (_a = link.source) == null ? void 0 : _a.id;
      const targetId = (_b = link.target) == null ? void 0 : _b.id;
      const sourceIsActive = activeNodeId ? sourceId === activeNodeId : false;
      const targetIsActive = activeNodeId ? targetId === activeNodeId : false;
      const sourceInRange = this.isInRange(sourceId, neighborsByHop);
      const targetInRange = this.isInRange(targetId, neighborsByHop);
      let tint;
      let alpha;
      let width;
      switch (this.settings.edgeColorMode) {
        case "inherit" /* INHERIT */:
          const sourceStyle = this.nodeStyles.get(sourceId || "");
          tint = (_c = sourceStyle == null ? void 0 : sourceStyle.tint) != null ? _c : this.parseColor("#888888");
          if (sourceIsActive || targetIsActive) {
            alpha = 1;
            width = this.settings.activeEdgeWidth;
          } else if (sourceInRange && targetInRange) {
            alpha = Math.min((_d = sourceStyle == null ? void 0 : sourceStyle.alpha) != null ? _d : 0.8, 0.8);
            width = this.settings.defaultEdgeWidth;
          } else {
            alpha = this.settings.disconnectedOpacity;
            width = this.settings.disconnectedEdgeWidth;
          }
          break;
        case "by-hop" /* BY_HOP */:
          const sourceHop = (_e = this.nodeHopLevels.get(sourceId || "")) != null ? _e : -1;
          const targetHop = (_f = this.nodeHopLevels.get(targetId || "")) != null ? _f : -1;
          if (sourceIsActive || targetIsActive) {
            tint = this.parseColor(this.settings.hopEdgeColors[0] || this.settings.edgeColor);
            alpha = 1;
            width = this.settings.activeEdgeWidth;
          } else {
            const minHop = Math.min(
              sourceHop > 0 ? sourceHop : Infinity,
              targetHop > 0 ? targetHop : Infinity
            );
            if (minHop <= this.settings.maxHops) {
              tint = this.parseColor(this.settings.hopEdgeColors[minHop - 1] || this.settings.edgeColor);
              alpha = 0.7;
              width = this.settings.defaultEdgeWidth;
            } else if (minHop !== Infinity) {
              tint = this.parseColor(this.settings.edgeColor);
              alpha = 0.4;
              width = this.settings.disconnectedEdgeWidth;
            } else {
              tint = this.parseColor(this.settings.edgeColor);
              alpha = this.settings.disconnectedOpacity;
              width = this.settings.disconnectedEdgeWidth;
            }
          }
          break;
        case "single" /* SINGLE */:
        default:
          if (sourceIsActive || targetIsActive) {
            tint = this.parseColor(this.settings.highlightedEdgeColor);
            alpha = 1;
            width = this.settings.activeEdgeWidth;
          } else if (sourceInRange && targetInRange) {
            tint = this.parseColor(this.settings.edgeColor);
            alpha = 0.8;
            width = this.settings.defaultEdgeWidth;
          } else {
            tint = this.parseColor(this.settings.edgeColor);
            alpha = this.settings.disconnectedOpacity;
            width = this.settings.disconnectedEdgeWidth;
          }
          break;
      }
      this.edgeStyles.set(link, { tint, alpha, width });
      if (link.line) {
        link.line.tint = tint;
        link.line.alpha = alpha;
        if (width !== 1 && link.line.scale) {
          link.line.scale.y *= width;
        }
      }
      if (link.arrow) {
        link.arrow.tint = tint;
      }
    });
  }
  isInRange(nodeId, neighborsByHop) {
    var _a;
    if (!nodeId)
      return false;
    for (let hop = 1; hop <= this.settings.maxHops; hop++) {
      if ((_a = neighborsByHop.get(hop)) == null ? void 0 : _a.has(nodeId))
        return true;
    }
    return false;
  }
  /**
   * Get style from unified rules (color, shape, size)
   * Rules are checked in order - first match wins (priority by index)
   */
  getStyleFromRules(nodeId) {
    if (!this.settings.rules || this.settings.rules.length === 0) {
      return null;
    }
    const file = this.app.vault.getAbstractFileByPath(nodeId);
    for (const rule of this.settings.rules) {
      if (!rule.enabled)
        continue;
      let matches = false;
      switch (rule.type) {
        case "folder":
          matches = nodeId.startsWith(rule.pattern);
          break;
        case "tag":
          matches = this.hasTag(file, rule.pattern);
          break;
        case "file":
          matches = nodeId === rule.pattern || nodeId.endsWith("/" + rule.pattern) || nodeId === rule.pattern + ".md" || nodeId.endsWith("/" + rule.pattern + ".md");
          break;
      }
      if (matches) {
        return {
          color: rule.color,
          shape: rule.shape,
          size: rule.size
        };
      }
    }
    return null;
  }
  /**
   * Check if a file has a specific tag
   */
  hasTag(file, tagPattern) {
    var _a;
    if (!(file instanceof import_obsidian2.TFile))
      return false;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache)
      return false;
    const normalizedPattern = tagPattern.startsWith("#") ? tagPattern : "#" + tagPattern;
    if (cache.tags) {
      for (const tagCache of cache.tags) {
        if (tagCache.tag === normalizedPattern || tagCache.tag.startsWith(normalizedPattern + "/")) {
          return true;
        }
      }
    }
    if ((_a = cache.frontmatter) == null ? void 0 : _a.tags) {
      const fmTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
      for (const tag of fmTags) {
        const normalizedTag = tag.startsWith("#") ? tag : "#" + tag;
        if (normalizedTag === normalizedPattern || normalizedTag.startsWith(normalizedPattern + "/")) {
          return true;
        }
      }
    }
    return false;
  }
  parseColor(color) {
    if (color.startsWith("#")) {
      return parseInt(color.slice(1), 16);
    }
    return 16777215;
  }
  clearStyles() {
    this.nodeStyles.clear();
    this.edgeStyles.clear();
    this.nodeHopLevels.clear();
    const renderer = this.getRenderer();
    if (renderer == null ? void 0 : renderer.nodes) {
      const nodeEntries = this.getNodeEntries(renderer.nodes);
      nodeEntries.forEach(([nodeId, node]) => {
        if (node.circle) {
          node.circle.alpha = 1;
        }
        if (node.text)
          node.text.alpha = 1;
      });
    }
    if (renderer == null ? void 0 : renderer.links) {
      renderer.links.forEach((link) => {
        if (link.line) {
          link.line.alpha = 1;
        }
      });
    }
  }
  cleanup() {
    this.stopTicker();
    const renderer = this.getRenderer();
    if (renderer == null ? void 0 : renderer.nodes) {
      const nodeEntries = this.getNodeEntries(renderer.nodes);
      nodeEntries.forEach(([nodeId, node]) => {
        const originalRender = this.originalRenderMethods.get(nodeId);
        if (originalRender && node) {
          node.render = originalRender;
        }
      });
    }
    if (renderer == null ? void 0 : renderer.links) {
      renderer.links.forEach((link) => {
        const originalRender = this.originalLinkRenderMethods.get(link);
        if (originalRender) {
          link.render = originalRender;
        }
      });
    }
    this.clearStyles();
    this.proxiedNodes.clear();
    this.proxiedLinks.clear();
    this.originalRenderMethods.clear();
    this.originalLinkRenderMethods.clear();
    this.nodeHopLevels.clear();
    this.lastNodeCount = 0;
    this.lastLinkCount = 0;
  }
  updateSettings(settings) {
    this.settings = settings;
    this.applyStyles();
  }
};

// src/main.ts
var GraphStyleCustomizerPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.stylers = /* @__PURE__ */ new Map();
    this.debouncedUpdate = (0, import_obsidian3.debounce)(() => {
      this.updateAllStylers();
    }, 100, true);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new GraphStyleSettingTab(this.app, this));
    this.addCommand({
      id: "toggle-graph-styling",
      name: "Toggle Graph Style Customizer",
      callback: () => {
        this.settings.enabled = !this.settings.enabled;
        this.saveSettings();
        this.updateAllStylers();
      }
    });
    this.addCommand({
      id: "cycle-preset",
      name: "Cycle through presets",
      callback: () => this.cyclePreset()
    });
    this.registerEvent(
      this.app.workspace.on("layout-change", () => this.handleLayoutChange())
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => this.debouncedUpdate())
    );
    this.registerEvent(
      this.app.workspace.on("file-open", () => this.debouncedUpdate())
    );
    this.app.workspace.onLayoutReady(() => {
      this.initializeStylers();
    });
    console.log("Graph Style Customizer loaded");
  }
  async onunload() {
    this.stylers.forEach((styler) => styler.cleanup());
    this.stylers.clear();
    console.log("Graph Style Customizer unloaded");
  }
  handleLayoutChange() {
    const graphLeaves = this.getGraphLeaves();
    const currentLeafIds = new Set(graphLeaves.map((l) => l.id));
    this.stylers.forEach((styler, leaf) => {
      if (!currentLeafIds.has(leaf.id)) {
        styler.cleanup();
        this.stylers.delete(leaf);
      }
    });
    graphLeaves.forEach((leaf) => {
      if (!this.stylers.has(leaf)) {
        const styler = new GraphStyler(leaf, this.settings, this.app);
        this.stylers.set(leaf, styler);
      }
    });
  }
  initializeStylers() {
    this.handleLayoutChange();
    setTimeout(() => this.updateAllStylers(), 500);
  }
  getGraphLeaves() {
    const leaves = [];
    if (this.settings.applyToGlobalGraph) {
      leaves.push(...this.app.workspace.getLeavesOfType("graph"));
    }
    if (this.settings.applyToLocalGraph) {
      leaves.push(...this.app.workspace.getLeavesOfType("localgraph"));
    }
    return leaves;
  }
  updateAllStylers() {
    this.stylers.forEach((styler) => {
      styler.updateSettings(this.settings);
      styler.applyStyles();
    });
  }
  cyclePreset() {
    if (this.settings.presets.length === 0)
      return;
    const currentIndex = this.settings.presets.findIndex(
      (p) => p.name === this.settings.activePreset
    );
    const nextIndex = (currentIndex + 1) % this.settings.presets.length;
    const preset = this.settings.presets[nextIndex];
    this.applyPreset(preset.name);
  }
  applyPreset(presetName) {
    const preset = this.settings.presets.find((p) => p.name === presetName);
    if (!preset)
      return;
    Object.assign(this.settings, preset.settings);
    this.settings.activePreset = presetName;
    this.saveSettings();
    this.updateAllStylers();
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    while (this.settings.hopColors.length < 5) {
      this.settings.hopColors.push(DEFAULT_SETTINGS.hopColors[this.settings.hopColors.length]);
    }
    if (!this.settings.hopEdgeColors) {
      this.settings.hopEdgeColors = [...DEFAULT_SETTINGS.hopEdgeColors];
    }
    while (this.settings.hopEdgeColors.length < 5) {
      this.settings.hopEdgeColors.push(DEFAULT_SETTINGS.hopEdgeColors[this.settings.hopEdgeColors.length]);
    }
    if (!this.settings.rules) {
      this.settings.rules = [];
    }
    if (this.settings.activeEdgeWidth === void 0) {
      this.settings.activeEdgeWidth = DEFAULT_SETTINGS.activeEdgeWidth;
    }
    if (this.settings.defaultEdgeWidth === void 0) {
      this.settings.defaultEdgeWidth = DEFAULT_SETTINGS.defaultEdgeWidth;
    }
    if (this.settings.disconnectedEdgeWidth === void 0) {
      this.settings.disconnectedEdgeWidth = DEFAULT_SETTINGS.disconnectedEdgeWidth;
    }
    let needsSave = false;
    if ((data == null ? void 0 : data.tagRules) && data.tagRules.length > 0) {
      const migratedTagRules = data.tagRules.map((r) => ({
        id: generateId(),
        type: "tag",
        pattern: r.tag,
        color: r.color,
        enabled: true
      }));
      this.settings.rules.push(...migratedTagRules);
      delete this.settings.tagRules;
      needsSave = true;
      console.log(`Migrated ${migratedTagRules.length} tag rules`);
    }
    if ((data == null ? void 0 : data.folderRules) && data.folderRules.length > 0) {
      const migratedFolderRules = data.folderRules.map((r) => ({
        id: generateId(),
        type: "folder",
        pattern: r.folder,
        color: r.color,
        enabled: true
      }));
      this.settings.rules.unshift(...migratedFolderRules);
      delete this.settings.folderRules;
      needsSave = true;
      console.log(`Migrated ${migratedFolderRules.length} folder rules`);
    }
    if (needsSave) {
      await this.saveData(this.settings);
      console.log("Settings migration completed");
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateAllStylers();
  }
};
